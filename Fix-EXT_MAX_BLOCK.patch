Ext4: fix invalid block number magic for >16 TB fs

From: Girish Shilamkar <Girish.Shilamkar@Sun.COM>

The magic constant EXT_MAX_BLOCK = 0xffffffff in extents code is used
in some places to return "invalid block number", and to set the extent
length = "whole file" in other places.

So with >= 16 TB fs we would prefer to use it differently. We can have
EXT_UNSET_BLOCK = 1 to indicate "invalid block number" as it will never
be valid block for allocation.  And for the "whole file" use case we can
continue using current EXT_MAX_BLOCK.

Signed-off-by:  Girish Shilamkar <Girish.Shilamkar@Sun.COM>
Signed-off-by:  Mingming Cao <cmm@us.ibm.com>
Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>
---
 fs/ext4/ext4_extents.h |    1 +
 fs/ext4/extents.c      |   20 ++++++++++----------
 2 files changed, 11 insertions(+), 10 deletions(-)

Index: linux-2.6.26-rc9/fs/ext4/ext4_extents.h
===================================================================
--- linux-2.6.26-rc9.orig/fs/ext4/ext4_extents.h	2008-07-08 16:52:23.000000000 -0700
+++ linux-2.6.26-rc9/fs/ext4/ext4_extents.h	2008-07-08 16:59:41.000000000 -0700
@@ -126,6 +126,7 @@ struct ext4_ext_path {
 
 
 #define EXT_MAX_BLOCK	0xffffffff
+#define EXT_UNSET_BLOCK 1
 
 /*
  * EXT_INIT_MAX_LEN is the maximum number of blocks we can have in an
Index: linux-2.6.26-rc9/fs/ext4/extents.c
===================================================================
--- linux-2.6.26-rc9.orig/fs/ext4/extents.c	2008-07-08 16:52:32.000000000 -0700
+++ linux-2.6.26-rc9/fs/ext4/extents.c	2008-07-08 16:59:41.000000000 -0700
@@ -1204,7 +1204,7 @@ ext4_ext_search_right(struct inode *inod
 
 /*
  * ext4_ext_next_allocated_block:
- * returns allocated block in subsequent extent or EXT_MAX_BLOCK.
+ * returns allocated block in subsequent extent or EXT_UNSET_BLOCK.
  * NOTE: it considers block number from index entry as
  * allocated block. Thus, index entries have to be consistent
  * with leaves.
@@ -1218,7 +1218,7 @@ ext4_ext_next_allocated_block(struct ext
 	depth = path->p_depth;
 
 	if (depth == 0 && path->p_ext == NULL)
-		return EXT_MAX_BLOCK;
+		return EXT_UNSET_BLOCK;
 
 	while (depth >= 0) {
 		if (depth == path->p_depth) {
@@ -1235,12 +1235,12 @@ ext4_ext_next_allocated_block(struct ext
 		depth--;
 	}
 
-	return EXT_MAX_BLOCK;
+	return EXT_UNSET_BLOCK;
 }
 
 /*
  * ext4_ext_next_leaf_block:
- * returns first allocated block from next leaf or EXT_MAX_BLOCK
+ * returns first allocated block from next leaf or EXT_UNSET_BLOCK
  */
 static ext4_lblk_t ext4_ext_next_leaf_block(struct inode *inode,
 					struct ext4_ext_path *path)
@@ -1252,7 +1252,7 @@ static ext4_lblk_t ext4_ext_next_leaf_bl
 
 	/* zero-tree has no leaf blocks at all */
 	if (depth == 0)
-		return EXT_MAX_BLOCK;
+		return EXT_UNSET_BLOCK;
 
 	/* go to index block */
 	depth--;
@@ -1265,7 +1265,7 @@ static ext4_lblk_t ext4_ext_next_leaf_bl
 		depth--;
 	}
 
-	return EXT_MAX_BLOCK;
+	return EXT_UNSET_BLOCK;
 }
 
 /*
@@ -1445,7 +1445,7 @@ unsigned int ext4_ext_check_overlap(stru
 	 */
 	if (b2 < b1) {
 		b2 = ext4_ext_next_allocated_block(path);
-		if (b2 == EXT_MAX_BLOCK)
+		if (b2 == EXT_UNSET_BLOCK)
 			goto out;
 	}
 
@@ -1524,7 +1524,7 @@ repeat:
 	fex = EXT_LAST_EXTENT(eh);
 	next = ext4_ext_next_leaf_block(inode, path);
 	if (le32_to_cpu(newext->ee_block) > le32_to_cpu(fex->ee_block)
-	    && next != EXT_MAX_BLOCK) {
+	    && next != EXT_UNSET_BLOCK) {
 		ext_debug("next leaf block - %d\n", next);
 		BUG_ON(npath != NULL);
 		npath = ext4_ext_find_extent(inode, next, NULL);
@@ -1883,8 +1883,8 @@ ext4_ext_rm_leaf(handle_t *handle, struc
 		path[depth].p_ext = ex;
 
 		a = ex_ee_block > start ? ex_ee_block : start;
-		b = ex_ee_block + ex_ee_len - 1 < EXT_MAX_BLOCK ?
-			ex_ee_block + ex_ee_len - 1 : EXT_MAX_BLOCK;
+		b = (unsigned long long)ex_ee_block + ex_ee_len - 1 <
+		    EXT_MAX_BLOCK ? ex_ee_block + ex_ee_len - 1 : EXT_MAX_BLOCK;
 
 		ext_debug("  border %u:%u\n", a, b);
 
