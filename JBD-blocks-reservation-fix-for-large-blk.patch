[RFC 2/2] JBD: blocks reservation fix for large block support

From: Mingming Cao <cmm@us.ibm.com>

The blocks per page could be less or quals to 1 with the large block support in VM.
The patch fixed the way to calculate the number of blocks to reserve in journal in the
case blocksize > pagesize.

But hch says:

Christoph Hellwig wrote:
> On Sun, Sep 02, 2007 at 04:40:21AM -0700, Christoph Lameter wrote:
>> On Sat, 1 Sep 2007, Christoph Hellwig wrote:
>>
>>> On Fri, Aug 31, 2007 at 05:12:18PM -0700, Mingming Cao wrote:
>>>> >From clameter:
>>>> Teach jbd/jbd2 slab management to support >8k block size. Without
>>>> this, it refused to mount on >8k ext3.
>>>
>>> But the real fix is to kill this code.  We can't send down slab pages
>>> down the block layer without breaking iscsi or aoe.  And this code is
>>> only used in so rare cases that all the normal testing won't hit it.
>>> Very bad combination.
>> We are doing what you describe right now. So the current code is broken?
> 
> Yes.

Signed-off-by: Mingming Cao <cmm@us.ibm.com>
---

 fs/jbd/journal.c  |    7 ++++++-
 fs/jbd2/journal.c |    7 ++++++-
 2 files changed, 12 insertions(+), 2 deletions(-)


Index: linux-2.6.23-rc8/fs/jbd/journal.c
===================================================================
--- linux-2.6.23-rc8.orig/fs/jbd/journal.c	2007-09-26 11:32:05.000000000 -0700
+++ linux-2.6.23-rc8/fs/jbd/journal.c	2007-09-26 11:33:04.000000000 -0700
@@ -1602,7 +1602,12 @@ void journal_ack_err(journal_t *journal)
 
 int journal_blocks_per_page(struct inode *inode)
 {
-	return 1 << (PAGE_CACHE_SHIFT - inode->i_sb->s_blocksize_bits);
+	int bits = PAGE_CACHE_SHIFT - inode->i_sb->s_blocksize_bits;
+
+	if (bits > 0)
+		return 1 << bits;
+	else
+		return 1;
 }
 
 /*
Index: linux-2.6.23-rc8/fs/jbd2/journal.c
===================================================================
--- linux-2.6.23-rc8.orig/fs/jbd2/journal.c	2007-09-26 11:32:34.000000000 -0700
+++ linux-2.6.23-rc8/fs/jbd2/journal.c	2007-09-26 11:33:04.000000000 -0700
@@ -1603,7 +1603,12 @@ void jbd2_journal_ack_err(journal_t *jou
 
 int jbd2_journal_blocks_per_page(struct inode *inode)
 {
-	return 1 << (PAGE_CACHE_SHIFT - inode->i_sb->s_blocksize_bits);
+	int bits = PAGE_CACHE_SHIFT - inode->i_sb->s_blocksize_bits;
+
+	if (bits > 0)
+		return 1 << bits;
+	else
+		return 1;
 }
 
 /*
