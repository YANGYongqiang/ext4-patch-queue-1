Ext4: journal credit fix the delalloc writepages

From: Mingming Cao <cmm@us.ibm.com>

Previous delalloc writepages implementation start a new transaction outside
a loop call of get_block() to do the block allocation. Due to lack of
information of how many blocks to be allocated, the estimate of the journal
credits is very conservtive and caused many issues.

With the rewored delayed allocation, a new transaction is created for
each get_block(), thus we don't need to guess how many credits for the multiple
chunk of allocation. Start every transaction with credits for insert a
single exent is enough. When estimate the credits for indirect blocks 
to allocate a chunk of blocks, it needs to know the number of data blocks to
allocate. We use the total number of reserved delalloc datablocks, if that
gets too big, for non extent file, we need to limit to the EXT4_MAX_TRANS_BLOCKS

Signed-off-by: Mingming Cao <cmm@us.ibm.com>
Reviewed-off-by:  Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>
---
 fs/ext4/inode.c |   51 ++++++++++++++++++++++++++++++++++++---------------
 1 file changed, 36 insertions(+), 15 deletions(-)

Index: linux-2.6.27-rc3/fs/ext4/inode.c
===================================================================
--- linux-2.6.27-rc3.orig/fs/ext4/inode.c	2008-08-18 12:20:23.000000000 -0700
+++ linux-2.6.27-rc3/fs/ext4/inode.c	2008-08-18 12:20:55.000000000 -0700
@@ -1850,8 +1850,18 @@ static void mpage_add_bh_to_extent(struc
 {
 	struct buffer_head *lbh = &mpd->lbh;
 	sector_t next;
+	int nrblocks = lbh->b_size >> mpd->inode->i_blkbits;
 
-	next = lbh->b_blocknr + (lbh->b_size >> mpd->inode->i_blkbits);
+	/* check if thereserved journal credits might overflow */
+	if (!(EXT4_I(mpd->inode)->i_flags & EXT4_EXTENTS_FL) &&
+	     (nrblocks >= EXT4_MAX_TRANS_DATA))
+		/*
+		 * With noextent format we are limited by the journal
+		 * credit available. Total credit needed to insert
+		 * nrblocks contiguous blocks is dependent on the
+		 * nrblocks. So limit nrblocks.
+		 */
+		goto flush_it;
 
 	/*
 	 * First block in the extent
@@ -1863,6 +1873,7 @@ static void mpage_add_bh_to_extent(struc
 		return;
 	}
 
+	next = lbh->b_blocknr + nrblocks;
 	/*
 	 * Can we merge the block to our big extent?
 	 */
@@ -1871,6 +1882,7 @@ static void mpage_add_bh_to_extent(struc
 		return;
 	}
 
+flush_it:
 	/*
 	 * We couldn't merge the block to our extent, so we
 	 * need to flush current  extent and start new one
@@ -2231,17 +2243,27 @@ static int ext4_da_writepage(struct page
 }
 
 /*
- * For now just follow the DIO way to estimate the max credits
- * needed to write out EXT4_MAX_WRITEBACK_PAGES.
- * todo: need to calculate the max credits need for
- * extent based files, currently the DIO credits is based on
- * indirect-blocks mapping way.
+ * This is called via ext4_da_writepages() to
+ * calulate the total number of credits to reserve to fit
+ * a single extent allocation into a single transaction,
+ * ext4_da_writpeages() will loop calling this before
+ * the block allocation.
  *
- * Probably should have a generic way to calculate credits
- * for DIO, writepages, and truncate
+ * The page vector size limited the max number of pages could
+ * be writeout at a time. Based on this, the max blocks to pass to
+ * get_block is calculated
  */
-#define EXT4_MAX_WRITEBACK_PAGES      DIO_MAX_BLOCKS
-#define EXT4_MAX_WRITEBACK_CREDITS    25
+
+static int ext4_writepages_trans_blocks(struct inode *inode)
+{
+	int max_blocks = EXT4_I(inode)->i_reserved_data_blocks;
+
+	if (!(inode->i_flags & EXT4_EXTENTS_FL) &&
+	    (max_blocks > EXT4_MAX_TRANS_DATA))
+		max_blocks = EXT4_MAX_TRANS_DATA;
+
+	return ext4_chunk_trans_blocks(inode, max_blocks);
+}
 
 static int ext4_da_writepages(struct address_space *mapping,
                                 struct writeback_control *wbc)
@@ -2283,7 +2305,7 @@ restart_loop:
 		 * by delalloc
 		 */
 		BUG_ON(ext4_should_journal_data(inode));
-		needed_blocks = EXT4_DATA_TRANS_BLOCKS(inode->i_sb);
+		needed_blocks = ext4_writepages_trans_blocks(inode);
 
 		/* start a new transaction*/
 		handle = ext4_journal_start(inode, needed_blocks);
@@ -4461,11 +4483,9 @@ int ext4_meta_trans_blocks(struct inode 
  * the modification of a single pages into a single transaction,
  * which may include multile chunk of block allocations.
  *
- * This could be called via ext4_write_begin() or later
- * ext4_da_writepages() in delalyed allocation case.
+ * This could be called via ext4_write_begin()
  *
- * In both case it's possible that we could allocating multiple
- * chunks of blocks. We need to consider the worse case, when
+ * We need to consider the worse case, when
  * one new block per extent.
  */
 int ext4_writepage_trans_blocks(struct inode *inode)
