ext4: Add sparse annotations for the group info semaphore

From: "Aneesh Kumar K.V" <aneesh.kumar@linux.vnet.ibm.com>

Signed-off-by: Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>
Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>
---
 fs/ext4/mballoc.c |   24 ++++++++++++++++++++----
 1 files changed, 20 insertions(+), 4 deletions(-)

diff --git a/fs/ext4/mballoc.c b/fs/ext4/mballoc.c
index 3c170c5..2368789 100644
--- a/fs/ext4/mballoc.c
+++ b/fs/ext4/mballoc.c
@@ -895,6 +895,7 @@ out:
 static noinline_for_stack int
 ext4_mb_load_buddy(struct super_block *sb, ext4_group_t group,
 					struct ext4_buddy *e4b)
+__acquires(e4b->alloc_semp)
 {
 	int blocks_per_page;
 	int block;
@@ -926,6 +927,7 @@ ext4_mb_load_buddy(struct super_block *sb, ext4_group_t group,
 	 * till we are done with allocation
 	 */
 	down_read(e4b->alloc_semp);
+	__acquire(e4b->alloc_semp);
 
 	/*
 	 * the buddy cache inode stores the block bitmap
@@ -1021,6 +1023,7 @@ err:
 }
 
 static void ext4_mb_release_desc(struct ext4_buddy *e4b)
+__releases(e4b->alloc_semp)
 {
 	if (e4b->bd_bitmap_page)
 		page_cache_release(e4b->bd_bitmap_page);
@@ -1028,6 +1031,7 @@ static void ext4_mb_release_desc(struct ext4_buddy *e4b)
 		page_cache_release(e4b->bd_buddy_page);
 	/* Done with the buddy cache */
 	up_read(e4b->alloc_semp);
+	__release(e4b->alloc_semp);
 }
 
 
@@ -1474,8 +1478,10 @@ static int ext4_mb_try_best_found(struct ext4_allocation_context *ac,
 
 	BUG_ON(ex.fe_len <= 0);
 	err = ext4_mb_load_buddy(ac->ac_sb, group, e4b);
-	if (err)
+	if (err) {
+		__release(e4b->alloc_semp);
 		return err;
+	}
 
 	ext4_lock_group(ac->ac_sb, group);
 	max = mb_find_extent(e4b, 0, ex.fe_start, ex.fe_len, &ex);
@@ -1505,8 +1511,10 @@ static int ext4_mb_find_by_goal(struct ext4_allocation_context *ac,
 		return 0;
 
 	err = ext4_mb_load_buddy(ac->ac_sb, group, e4b);
-	if (err)
+	if (err) {
+		__release(e4b->alloc_semp);
 		return err;
+	}
 
 	ext4_lock_group(ac->ac_sb, group);
 	max = mb_find_extent(e4b, 0, ac->ac_g_ex.fe_start,
@@ -2009,8 +2017,10 @@ repeat:
 				continue;
 
 			err = ext4_mb_load_buddy(sb, group, &e4b);
-			if (err)
+			if (err) {
+				__release(e4b->alloc_semp);
 				goto out;
+			}
 
 			ext4_lock_group(sb, group);
 			if (!ext4_mb_good_group(ac, group, cr)) {
@@ -2321,6 +2331,7 @@ static int ext4_mb_seq_groups_show(struct seq_file *seq, void *v)
 		sizeof(struct ext4_group_info);
 	err = ext4_mb_load_buddy(sb, group, &e4b);
 	if (err) {
+		__release(e4b->alloc_semp);
 		seq_printf(seq, "#%-5u: I/O error\n", group);
 		return 0;
 	}
@@ -3867,6 +3878,7 @@ ext4_mb_discard_group_preallocations(struct super_block *sb,
 
 	err = ext4_mb_load_buddy(sb, group, &e4b);
 	if (err) {
+		__release(e4b->alloc_semp);
 		ext4_error(sb, __func__, "Error in loading buddy "
 				"information for %u\n", group);
 		put_bh(bitmap_bh);
@@ -4034,6 +4046,7 @@ repeat:
 
 		err = ext4_mb_load_buddy(sb, group, &e4b);
 		if (err) {
+			__release(e4b->alloc_semp);
 			ext4_error(sb, __func__, "Error in loading buddy "
 					"information for %u\n", group);
 			continue;
@@ -4306,6 +4319,7 @@ ext4_mb_discard_lg_preallocations(struct super_block *sb,
 
 		ext4_get_group_no_and_offset(sb, pa->pa_pstart, &group, NULL);
 		if (ext4_mb_load_buddy(sb, group, &e4b)) {
+			__release(e4b->alloc_semp);
 			ext4_error(sb, __func__, "Error in loading buddy "
 					"information for %u\n", group);
 			continue;
@@ -4766,8 +4780,10 @@ do_more:
 	}
 
 	err = ext4_mb_load_buddy(sb, block_group, &e4b);
-	if (err)
+	if (err) {
+		__release(e4b->alloc_semp);
 		goto error_return;
+	}
 	if (metadata && ext4_handle_valid(handle)) {
 		/* blocks being freed are metadata. these blocks shouldn't
 		 * be used until this transaction is committed */
