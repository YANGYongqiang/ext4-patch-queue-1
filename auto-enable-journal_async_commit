ext4: Automatically enable journal_async_commit on ext4 file systems

Now that we have cleaned up journal_async_commit, it's safe to enable
it all the time.  But we only want to do so if ext4-specific INCOMPAT
features are enabled, since otherwise we will prevent the filesystem
from being mounted using ext3.

Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>

diff --git a/Documentation/filesystems/ext4.txt b/Documentation/filesystems/ext4.txt
index 6d94e06..05106b5 100644
--- a/Documentation/filesystems/ext4.txt
+++ b/Documentation/filesystems/ext4.txt
@@ -140,9 +140,14 @@ journal_checksum	Enable checksumming of the journal transactions.
 			compatible change and will be ignored by older kernels.
 
 journal_async_commit	Commit block can be written to disk without waiting
-			for descriptor blocks. If enabled older kernels cannot
-			mount the device. This will enable 'journal_checksum'
-			internally.
+			for descriptor blocks.  This will enable
+			'journal_checksum' internally.  This mount
+			option will be automatically enabled if
+			ext4-specific INCOMPAT features are present in
+			the file system.
+
+nojournal_async_commit	Disable the journal_async_commit option, even
+			for ext4 filesystems.
 
 journal=update		Update the ext4 file system's journal to the current
 			format.
diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index d4ca92a..87a71e6 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -69,6 +69,15 @@ static int ext4_unfreeze(struct super_block *sb);
 static void ext4_write_super(struct super_block *sb);
 static int ext4_freeze(struct super_block *sb);
 
+/*
+ * If ext4 filesystem features are enabled, then enable async_commits
+ * by default.
+ */
+#define ASYNC_COMMIT_DEFAULT(sb) (EXT4_HAS_INCOMPAT_FEATURE(sb, \
+					(EXT4_FEATURE_INCOMPAT_EXTENTS| \
+					 EXT4_FEATURE_INCOMPAT_64BIT| \
+					 EXT4_FEATURE_INCOMPAT_FLEX_BG)))
+
 
 ext4_fsblk_t ext4_block_bitmap(struct super_block *sb,
 			       struct ext4_group_desc *bg)
@@ -866,8 +875,13 @@ static int ext4_show_options(struct seq_file *seq, struct vfsmount *vfs)
 	 */
 	seq_puts(seq, ",barrier=");
 	seq_puts(seq, test_opt(sb, BARRIER) ? "1" : "0");
-	if (test_opt(sb, JOURNAL_ASYNC_COMMIT))
-		seq_puts(seq, ",journal_async_commit");
+	if (ASYNC_COMMIT_DEFAULT(sb)) {
+		if (!test_opt(sb, JOURNAL_ASYNC_COMMIT))
+			seq_puts(seq, ",nojournal_async_commit");
+	} else {
+		if (test_opt(sb, JOURNAL_ASYNC_COMMIT))
+			seq_puts(seq, ",journal_async_commit");
+	}
 	if (test_opt(sb, NOBH))
 		seq_puts(seq, ",nobh");
 	if (test_opt(sb, I_VERSION))
@@ -1071,6 +1085,7 @@ enum {
 	Opt_commit, Opt_min_batch_time, Opt_max_batch_time,
 	Opt_journal_update, Opt_journal_dev,
 	Opt_journal_checksum, Opt_journal_async_commit,
+	Opt_nojournal_async_commit,
 	Opt_abort, Opt_data_journal, Opt_data_ordered, Opt_data_writeback,
 	Opt_data_err_abort, Opt_data_err_ignore,
 	Opt_usrjquota, Opt_grpjquota, Opt_offusrjquota, Opt_offgrpjquota,
@@ -1113,6 +1128,7 @@ static const match_table_t tokens = {
 	{Opt_journal_dev, "journal_dev=%u"},
 	{Opt_journal_checksum, "journal_checksum"},
 	{Opt_journal_async_commit, "journal_async_commit"},
+	{Opt_nojournal_async_commit, "nojournal_async_commit"},
 	{Opt_abort, "abort"},
 	{Opt_data_journal, "data=journal"},
 	{Opt_data_ordered, "data=ordered"},
@@ -1306,6 +1322,9 @@ static int parse_options(char *options, struct super_block *sb,
 			set_opt(sbi->s_mount_opt, JOURNAL_ASYNC_COMMIT);
 			set_opt(sbi->s_mount_opt, JOURNAL_CHECKSUM);
 			break;
+		case Opt_nojournal_async_commit:
+			clear_opt(sbi->s_mount_opt, JOURNAL_ASYNC_COMMIT);
+			break;
 		case Opt_noload:
 			set_opt(sbi->s_mount_opt, NOLOAD);
 			break;
@@ -2431,6 +2450,9 @@ static int ext4_fill_super(struct super_block *sb, void *data, int silent)
 	 */
 	set_opt(sbi->s_mount_opt, DELALLOC);
 
+	if (ASYNC_COMMIT_DEFAULT(sb))
+		set_opt(sbi->s_mount_opt, JOURNAL_ASYNC_COMMIT);
+
 	if (!parse_options((char *) data, sb, &journal_devnum,
 			   &journal_ioprio, NULL, 0))
 		goto failed_mount;
