ext4: delalloc i_disksize update fix

From: Mingming Cao <cmm@us.ibm.com>

Currently with delayed allocation, it does not update
i_disksize until real block allocation at page writeout time.
i_disksize is updated after block allocation is done.

But the current code missed to update the i_disksize if 
write to the eof but not requiring block allocation 
(buffer has already mapped), when writepage() is called
via shrink_page_list.

Reviewed-by: Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>
Signed-off-by: Mingming Cao <cmm@us.ibm.com>

---
 fs/ext4/inode.c |   73 +++++++++++++++++++++++++++++++++++++++++++++++++++-----
 1 file changed, 67 insertions(+), 6 deletions(-)

Index: linux-2.6.26-rc6/fs/ext4/inode.c
===================================================================
--- linux-2.6.26-rc6.orig/fs/ext4/inode.c	2008-06-23 17:28:01.000000000 -0700
+++ linux-2.6.26-rc6/fs/ext4/inode.c	2008-06-24 14:56:04.000000000 -0700
@@ -1553,11 +1553,25 @@ static int ext4_da_write_begin(struct fi
  	struct page *page;
  	pgoff_t index;
  	unsigned from, to;
+	struct inode *inode = mapping->host;
+	handle_t *handle;
 
  	index = pos >> PAGE_CACHE_SHIFT;
  	from = pos & (PAGE_CACHE_SIZE - 1);
  	to = from + len;
 
+	/*
+	 * With delayed allocation, we don't log the i_disksize update
+	 * if there is delayed block allocation. But we still need
+	 * to journalling the i_disksize update if writes to the end
+	 * of file which has an already mapped buffer.
+	 */
+	handle = ext4_journal_start(inode, 1);
+	if (IS_ERR(handle)) {
+		ret = PTR_ERR(handle);
+		goto out;
+	}
+
  	page = __grab_cache_page(mapping, index);
  	if (!page)
  		return -ENOMEM;
@@ -1567,12 +1581,66 @@ static int ext4_da_write_begin(struct fi
 							ext4_da_get_block_prep);
 	if (ret < 0) {
 		unlock_page(page);
+		ext4_journal_stop(handle);
 		page_cache_release(page);
 	}
 
+out:
 	return ret;
 }
 
+static int ext4_bh_unmapped_or_delay(handle_t *handle, struct buffer_head *bh)
+{
+	return !buffer_mapped(bh) || buffer_delay(bh);
+}
+
+static int ext4_da_write_end(struct file *file,
+				struct address_space *mapping,
+				loff_t pos, unsigned len, unsigned copied,
+				struct page *page, void *fsdata)
+{
+	struct inode *inode = mapping->host;
+	unsigned from, to;
+	int ret = 0, ret2;
+	handle_t *handle = ext4_journal_current_handle();
+
+	from = pos & (PAGE_CACHE_SIZE - 1);
+	to = from + len;
+
+	if (ret == 0) {
+		/*
+		 * generic_write_end() will run mark_inode_dirty() if i_size
+		 * changes.  So let's piggyback the i_disksize mark_inode_dirty
+		 * into that.
+		 */
+		loff_t new_i_size;
+
+		new_i_size = pos + copied;
+		if (new_i_size > EXT4_I(inode)->i_disksize)
+			if (!walk_page_buffers(NULL, page_buffers(page),
+					       0, len, NULL, ext4_bh_unmapped_or_delay)){
+				/*
+				 * Updating i_disksize when extending file without
+				 * need block allocation
+				 */
+				if (ext4_should_order_data(inode))
+					ret = ext4_jbd2_file_inode(handle, inode);
+
+				EXT4_I(inode)->i_disksize = new_i_size;
+			}
+		ret2 = generic_write_end(file, mapping, pos, len, copied,
+							page, fsdata);
+		copied = ret2;
+		if (ret2 < 0)
+			ret = ret2;
+	}
+	ret2 = ext4_journal_stop(handle);
+	if (!ret)
+		ret = ret2;
+
+	return ret ? ret : copied;
+}
+
 static void ext4_da_invalidatepage(struct page *page, unsigned long offset)
 {
 	struct buffer_head *head, *bh;
@@ -1682,11 +1750,6 @@ static int bput_one(handle_t *handle, st
 	return 0;
 }
 
-static int ext4_bh_unmapped_or_delay(handle_t *handle, struct buffer_head *bh)
-{
-	return !buffer_mapped(bh) || buffer_delay(bh);
-}
-
 /*
  * Note that we don't need to start a transaction unless we're journaling data
  * because we should have holes filled from ext4_page_mkwrite(). We even don't
@@ -2050,7 +2113,7 @@ static const struct address_space_operat
 	.writepages	= ext4_da_writepages,
 	.sync_page	= block_sync_page,
 	.write_begin	= ext4_da_write_begin,
-	.write_end	= generic_write_end,
+	.write_end	= ext4_da_write_end,
 	.bmap		= ext4_bmap,
 	.invalidatepage	= ext4_da_invalidatepage,
 	.releasepage	= ext4_releasepage,
