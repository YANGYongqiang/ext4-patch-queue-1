ext3: Return after ext3_error in case of failures

From: Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>

This fix some instances where we were continuing
after calling ext3_error. ext3_error calls panic
only if errors=panic mount option is set. So
we need to make sure we return correctly after
ext3_error call

Signed-off-by: Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>
---

 fs/ext3/balloc.c |   12 +++++++++---
 1 files changed, 9 insertions(+), 3 deletions(-)


diff --git a/fs/ext3/balloc.c b/fs/ext3/balloc.c
index 7a87d15..4cc1091 100644
--- a/fs/ext3/balloc.c
+++ b/fs/ext3/balloc.c
@@ -111,11 +111,13 @@ read_block_bitmap(struct super_block *sb, unsigned int block_group)
 		return NULL;
 	bitmap_blk = le32_to_cpu(desc->bg_block_bitmap);
 	bh = sb_bread(sb, bitmap_blk);
-	if (!bh)
+	if (!bh) {
 		ext3_error (sb, __FUNCTION__,
 			    "Cannot read block bitmap - "
 			    "block_group = %d, block_bitmap = %u",
 			    block_group, le32_to_cpu(desc->bg_block_bitmap));
+		return NULL;
+	}
 
 	/* check whether block bitmap block number is set */
 	if (!block_in_use(bitmap_blk, sb, bh->b_data)) {
@@ -507,11 +509,13 @@ do_more:
 	    in_range (block, le32_to_cpu(desc->bg_inode_table),
 		      sbi->s_itb_per_group) ||
 	    in_range (block + count - 1, le32_to_cpu(desc->bg_inode_table),
-		      sbi->s_itb_per_group))
+		      sbi->s_itb_per_group)) {
 		ext3_error (sb, "ext3_free_blocks",
 			    "Freeing blocks in system zones - "
 			    "Block = "E3FSBLK", count = %lu",
 			    block, count);
+		goto error_return;
+	}
 
 	/*
 	 * We are about to start releasing blocks in the bitmap,
@@ -1614,11 +1618,13 @@ allocated:
 	    in_range(ret_block, le32_to_cpu(gdp->bg_inode_table),
 		      EXT3_SB(sb)->s_itb_per_group) ||
 	    in_range(ret_block + num - 1, le32_to_cpu(gdp->bg_inode_table),
-		      EXT3_SB(sb)->s_itb_per_group))
+		      EXT3_SB(sb)->s_itb_per_group)) {
 		ext3_error(sb, "ext3_new_block",
 			    "Allocating block in system zone - "
 			    "blocks from "E3FSBLK", length %lu",
 			     ret_block, num);
+		goto out;
+	}
 
 	performed_allocation = 1;
 
