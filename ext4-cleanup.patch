ext4: Code cleanup

From: Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>

a) Introduce ext4_update_*_feature(sb,
b) rename i_file_acl to i_file_acl_lo
c) convert some function to static
d) Fix sparse warnings

Signed-off-by: Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>
---

 fs/ext4/extents.c       |    6 +++--
 fs/ext4/ialloc.c        |   13 +++++-------
 fs/ext4/inode.c         |   18 +++++++++-------
 fs/ext4/super.c         |   52 ++++++++++++++++++++++++++++++++++++++++++++++-
 include/linux/ext4_fs.h |   10 ++++++++-
 5 files changed, 79 insertions(+), 20 deletions(-)


Index: linux-2.6.23/fs/ext4/extents.c
===================================================================
--- linux-2.6.23.orig/fs/ext4/extents.c	2007-10-16 17:36:23.000000000 -0700
+++ linux-2.6.23/fs/ext4/extents.c	2007-10-16 17:36:34.000000000 -0700
@@ -1230,7 +1230,7 @@ static ext4_lblk_t ext4_ext_next_leaf_bl
  * then we have to correct all indexes above.
  * TODO: do we need to correct tree in all cases?
  */
-int ext4_ext_correct_indexes(handle_t *handle, struct inode *inode,
+static int ext4_ext_correct_indexes(handle_t *handle, struct inode *inode,
 				struct ext4_ext_path *path)
 {
 	struct ext4_extent_header *eh;
@@ -1677,7 +1677,7 @@ ext4_ext_in_cache(struct inode *inode, e
  * It's used in truncate case only, thus all requests are for
  * last index in the block only.
  */
-int ext4_ext_rm_idx(handle_t *handle, struct inode *inode,
+static int ext4_ext_rm_idx(handle_t *handle, struct inode *inode,
 			struct ext4_ext_path *path)
 {
 	struct buffer_head *bh;
@@ -1947,7 +1947,7 @@ ext4_ext_more_to_rm(struct ext4_ext_path
 	return 1;
 }
 
-int ext4_ext_remove_space(struct inode *inode, unsigned long start)
+static int ext4_ext_remove_space(struct inode *inode, unsigned long start)
 {
 	struct super_block *sb = inode->i_sb;
 	int depth = ext_depth(inode);
Index: linux-2.6.23/fs/ext4/ialloc.c
===================================================================
--- linux-2.6.23.orig/fs/ext4/ialloc.c	2007-10-16 17:36:16.000000000 -0700
+++ linux-2.6.23/fs/ext4/ialloc.c	2007-10-16 17:36:34.000000000 -0700
@@ -750,13 +750,12 @@ got:
 	if (test_opt(sb, EXTENTS)) {
 		EXT4_I(inode)->i_flags |= EXT4_EXTENTS_FL;
 		ext4_ext_tree_init(handle, inode);
-		if (!EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_EXTENTS)) {
-			err = ext4_journal_get_write_access(handle, EXT4_SB(sb)->s_sbh);
-			if (err) goto fail;
-			EXT4_SET_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_EXTENTS);
-			BUFFER_TRACE(EXT4_SB(sb)->s_sbh, "call ext4_journal_dirty_metadata");
-			err = ext4_journal_dirty_metadata(handle, EXT4_SB(sb)->s_sbh);
-		}
+		err = ext4_update_incompat_feature(handle, sb,
+						EXT4_FEATURE_INCOMPAT_EXTENTS);
+		if (err)
+			goto fail;
+
+		BUFFER_TRACE(EXT4_SB(sb)->s_sbh, "call ext4_update_feautre");
 	}
 
 	ext4_debug("allocating inode %lu\n", inode->i_ino);
Index: linux-2.6.23/fs/ext4/inode.c
===================================================================
--- linux-2.6.23.orig/fs/ext4/inode.c	2007-10-16 17:36:23.000000000 -0700
+++ linux-2.6.23/fs/ext4/inode.c	2007-10-16 17:36:34.000000000 -0700
@@ -2093,11 +2093,11 @@ static void ext4_clear_blocks(handle_t *
 	for (p = first; p < last; p++) {
 		u32 nr = le32_to_cpu(*p);
 		if (nr) {
-			struct buffer_head *bh;
+			struct buffer_head *tbh;
 
 			*p = 0;
-			bh = sb_find_get_block(inode->i_sb, nr);
-			ext4_forget(handle, 0, inode, bh, nr);
+			tbh = sb_find_get_block(inode->i_sb, nr);
+			ext4_forget(handle, 0, inode, tbh, nr);
 		}
 	}
 
@@ -2365,8 +2365,10 @@ void ext4_truncate(struct inode *inode)
 			return;
 	}
 
-	if (EXT4_I(inode)->i_flags & EXT4_EXTENTS_FL)
-		return ext4_ext_truncate(inode, page);
+	if (EXT4_I(inode)->i_flags & EXT4_EXTENTS_FL) {
+		ext4_ext_truncate(inode, page);
+		return;
+	}
 
 	handle = start_transaction(inode);
 	if (IS_ERR(handle)) {
@@ -2757,7 +2759,7 @@ void ext4_read_inode(struct inode * inod
 	}
 	inode->i_blocks = le32_to_cpu(raw_inode->i_blocks);
 	ei->i_flags = le32_to_cpu(raw_inode->i_flags);
-	ei->i_file_acl = le32_to_cpu(raw_inode->i_file_acl);
+	ei->i_file_acl = le32_to_cpu(raw_inode->i_file_acl_lo);
 	if (EXT4_SB(inode->i_sb)->s_es->s_creator_os !=
 	    cpu_to_le32(EXT4_OS_HURD))
 		ei->i_file_acl |=
@@ -2912,7 +2914,7 @@ static int ext4_do_update_inode(handle_t
 	    cpu_to_le32(EXT4_OS_HURD))
 		raw_inode->i_file_acl_high =
 			cpu_to_le16(ei->i_file_acl >> 32);
-	raw_inode->i_file_acl = cpu_to_le32(ei->i_file_acl);
+	raw_inode->i_file_acl_lo = cpu_to_le32(ei->i_file_acl);
 	if (!S_ISREG(inode->i_mode)) {
 		raw_inode->i_dir_acl = cpu_to_le32(ei->i_dir_acl);
 	} else {
@@ -3217,7 +3219,7 @@ ext4_reserve_inode_write(handle_t *handl
  * Expand an inode by new_extra_isize bytes.
  * Returns 0 on success or negative error number on failure.
  */
-int ext4_expand_extra_isize(struct inode *inode, unsigned int new_extra_isize,
+static int ext4_expand_extra_isize(struct inode *inode, unsigned int new_extra_isize,
 			struct ext4_iloc iloc, handle_t *handle)
 {
 	struct ext4_inode *raw_inode;
Index: linux-2.6.23/fs/ext4/super.c
===================================================================
--- linux-2.6.23.orig/fs/ext4/super.c	2007-10-16 17:36:23.000000000 -0700
+++ linux-2.6.23/fs/ext4/super.c	2007-10-16 17:36:34.000000000 -0700
@@ -372,7 +372,57 @@ void ext4_update_dynamic_rev(struct supe
 	 * can leave it up to e2fsck to clean up any inconsistencies there.
 	 */
 }
-
+int ext4_update_compat_feature(handle_t *handle,
+					struct super_block *sb, __u32 compat)
+{
+	int err = 0;
+	if (!EXT4_HAS_COMPAT_FEATURE(sb, compat)) {
+		err = ext4_journal_get_write_access(handle,
+				EXT4_SB(sb)->s_sbh);
+		if (err)
+			return err;
+		EXT4_SET_COMPAT_FEATURE(sb, compat);
+		sb->s_dirt = 1;
+		handle->h_sync = 1;
+		err = ext4_journal_dirty_metadata(handle,
+				EXT4_SB(sb)->s_sbh);
+	}
+	return err;
+}
+int ext4_update_rocompat_feature(handle_t *handle,
+					struct super_block *sb, __u32 rocompat)
+{
+	int err = 0;
+	if (!EXT4_HAS_RO_COMPAT_FEATURE(sb, rocompat)) {
+		err = ext4_journal_get_write_access(handle,
+				EXT4_SB(sb)->s_sbh);
+		if (err)
+			return err;
+		EXT4_SET_RO_COMPAT_FEATURE(sb, rocompat);
+		sb->s_dirt = 1;
+		handle->h_sync = 1;
+		err = ext4_journal_dirty_metadata(handle,
+				EXT4_SB(sb)->s_sbh);
+	}
+	return err;
+}
+int ext4_update_incompat_feature(handle_t *handle,
+					struct super_block *sb, __u32 incompat)
+{
+	int err = 0;
+	if (!EXT4_HAS_INCOMPAT_FEATURE(sb, incompat)) {
+		err = ext4_journal_get_write_access(handle,
+				EXT4_SB(sb)->s_sbh);
+		if (err)
+			return err;
+		EXT4_SET_INCOMPAT_FEATURE(sb, incompat);
+		sb->s_dirt = 1;
+		handle->h_sync = 1;
+		err = ext4_journal_dirty_metadata(handle,
+				EXT4_SB(sb)->s_sbh);
+	}
+	return err;
+}
 /*
  * Open the external journal device
  */
Index: linux-2.6.23/include/linux/ext4_fs.h
===================================================================
--- linux-2.6.23.orig/include/linux/ext4_fs.h	2007-10-16 17:36:23.000000000 -0700
+++ linux-2.6.23/include/linux/ext4_fs.h	2007-10-16 17:36:34.000000000 -0700
@@ -325,7 +325,7 @@ struct ext4_inode {
 	} osd1;				/* OS dependent 1 */
 	__le32	i_block[EXT4_N_BLOCKS];/* Pointers to blocks */
 	__le32	i_generation;	/* File version (for NFS) */
-	__le32	i_file_acl;	/* File ACL */
+	__le32	i_file_acl_lo;	/* File ACL */
 	__le32	i_dir_acl;	/* Directory ACL */
 	__le32	i_obso_faddr;	/* Obsoleted fragment address */
 	union {
@@ -928,6 +928,8 @@ extern ext4_fsblk_t ext4_new_block (hand
 			ext4_fsblk_t goal, int *errp);
 extern ext4_fsblk_t ext4_new_blocks (handle_t *handle, struct inode *inode,
 			ext4_fsblk_t goal, unsigned long *count, int *errp);
+extern ext4_fsblk_t ext4_new_blocks_old (handle_t *handle, struct inode *inode,
+			ext4_fsblk_t goal, unsigned long *count, int *errp);
 extern void ext4_free_blocks (handle_t *handle, struct inode *inode,
 			ext4_fsblk_t block, unsigned long count, int metadata);
 extern void ext4_free_blocks_sb (handle_t *handle, struct super_block *sb,
@@ -1039,6 +1041,12 @@ extern void ext4_abort (struct super_blo
 extern void ext4_warning (struct super_block *, const char *, const char *, ...)
 	__attribute__ ((format (printf, 3, 4)));
 extern void ext4_update_dynamic_rev (struct super_block *sb);
+extern int ext4_update_compat_feature(handle_t *handle, struct super_block *sb,
+					__u32 compat);
+extern int ext4_update_rocompat_feature(handle_t *handle, struct super_block *sb,
+					__u32 rocompat);
+extern int ext4_update_incompat_feature(handle_t *handle, struct super_block *sb,
+					__u32 incompat);
 extern ext4_fsblk_t ext4_block_bitmap(struct super_block *sb,
 				      struct ext4_group_desc *bg);
 extern ext4_fsblk_t ext4_inode_bitmap(struct super_block *sb,
