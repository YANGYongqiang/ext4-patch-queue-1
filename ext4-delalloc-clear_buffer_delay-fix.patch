ext4: Need clear buffer_delay in ext4_da_writepage()

From: Mingming Cao <cmm@us.ibm.com>

Need clear buffer_delay in ext4_da_writepage() after page has been writeout

Signed-off-by: Mingming Cao <cmm@us.ibm.com>

---
 fs/ext4/inode.c |   27 +++++++++++++++++----------
 1 file changed, 17 insertions(+), 10 deletions(-)

Index: linux-2.6.26-rc4/fs/ext4/inode.c
===================================================================
--- linux-2.6.26-rc4.orig/fs/ext4/inode.c	2008-06-01 13:39:14.000000000 -0700
+++ linux-2.6.26-rc4/fs/ext4/inode.c	2008-06-01 13:40:00.000000000 -0700
@@ -1495,6 +1495,13 @@ static int ext4_bh_unmapped_or_delay(han
 	return (!buffer_mapped(bh) || buffer_delay(bh));
 }
 
+static int ext4_bh_clear_delay(handle_t *handle, struct buffer_head *bh)
+{
+	clear_buffer_delay(bh);
+	return 1;
+}
+
+
 /* FIXME!! only support data=writeback mode */
 /*
  * get called vi ext4_da_writepages after taking page lock
@@ -1508,10 +1515,16 @@ static int ext4_da_writepage(struct page
 	loff_t size;
 	unsigned long len;
 	handle_t *handle = NULL;
-	struct buffer_head *page_bufs;
+	struct buffer_head *page_bufs = page_buffers(page);
 	struct inode *inode = page->mapping->host;
 
+	size = i_size_read(inode);
+	if (page->index == size >> PAGE_CACHE_SHIFT)
+		len = size & ~PAGE_CACHE_MASK;
+	else
+		len = PAGE_CACHE_SIZE;
 	handle = ext4_journal_current_handle();
+
 	if (!handle) {
 		/*
 		 * This can happen when we aren't called via
@@ -1519,14 +1532,6 @@ static int ext4_da_writepage(struct page
 		 * We cannot easily start a transaction here so we just skip
 		 * writing the page in case we would have to do so.
 		 */
-		size = i_size_read(inode);
-
-		page_bufs = page_buffers(page);
-		if (page->index == size >> PAGE_CACHE_SHIFT)
-			len = size & ~PAGE_CACHE_MASK;
-		else
-			len = PAGE_CACHE_SIZE;
-
 		if (walk_page_buffers(NULL, page_bufs, 0,
 				len, NULL, ext4_bh_unmapped_or_delay)) {
 			/*
@@ -1544,7 +1549,9 @@ static int ext4_da_writepage(struct page
 		ret = nobh_writepage(page, ext4_da_get_block_write, wbc);
 	else
 		ret = block_write_full_page(page, ext4_da_get_block_write, wbc);
-
+	if (ret == 0)
+		walk_page_buffers(NULL, page_bufs, 0,
+				len, NULL, ext4_bh_clear_delay);
 	return ret;
 }
 
