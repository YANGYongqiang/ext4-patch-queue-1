[RFC] ext4-delayed-allocation.patch

Hi Alex,

I tested your patch on my system with a 20TB device, but some tests
failed. Looking at the code, I saw that the support of 48-bit block
number in extents is lacking.

I made some changes in the code (see the patch in attachment) and now
all my tests are OK.
The patch is not complete, I didn't update calls to wb_debug() which
dump "ee_start".

Hope this helps.

Val√©rie

From: Valerie Clement <valerie.clement@bull.net>

---

 fs/ext4/writeback.c |   20 ++++++++++++++------
 1 file changed, 14 insertions(+), 6 deletions(-)

diff -Nurp linux007/fs/ext4/writeback.c linux008/fs/ext4/writeback.c
--- linux007/fs/ext4/writeback.c	2007-03-19 16:03:08.000000000 -0500
+++ linux008/fs/ext4/writeback.c	2007-03-19 16:03:08.000000000 -0500
@@ -274,7 +274,8 @@ static int ext4_wb_submit_extent(struct 
 	struct inode *inode = wc->mapping->host;
 	int blkbits = inode->i_blkbits;
 	struct page *page;
-	unsigned long blk, off, len, remain;
+	ext4_fsblk_t off;
+	unsigned long blk, len, remain;
 	unsigned long pstart, plen, prev;
 	struct bio *bio = NULL;
 	int nr_pages;
@@ -335,6 +336,8 @@ alloc_new_bio:
 			nr_pages = (nr_pages >> (PAGE_CACHE_SHIFT - blkbits));
 			off = le32_to_cpu(ex->ee_start) +
 			      (blk - le32_to_cpu(ex->ee_block));
+			off |= (ext4_fsblk_t)
+				le16_to_cpu(ex->ee_start_hi) << 32;
 			bio = ext4_wb_bio_alloc(inode, off, nr_pages + 2);
 			if (bio == NULL)
 				return -ENOMEM;
@@ -380,7 +383,9 @@ ext4_wb_find_goal(struct inode *inode, s
 		
 		/* try to predict block placement */
 		if ((ex = path[depth].p_ext))
-			return le32_to_cpu(ex->ee_start) +
+			return (le32_to_cpu(ex->ee_start) |
+				((ext4_fsblk_t)
+				 le16_to_cpu(ex->ee_start_hi) << 32)) +
 			       (block - le32_to_cpu(ex->ee_block));
 
 		/* it looks index is empty
@@ -420,7 +425,8 @@ static int ext4_wb_handle_extent(struct 
 				(unsigned) ec->ec_block,
 				(unsigned) ec->ec_len,
 				(unsigned) ec->ec_start);
-		nex.ee_start = cpu_to_le32(ec->ec_start);
+		nex.ee_start = cpu_to_le32(ec->ec_start & 0xffffffff);
+		nex.ee_start_hi = cpu_to_le16((ec->ec_start >> 32) & 0xffff);
 		nex.ee_block = cpu_to_le32(ec->ec_block);
 		nex.ee_len = cpu_to_le16(ec->ec_len);
 		err = ext4_wb_submit_extent(wc, NULL, &nex, 0);
@@ -493,8 +499,8 @@ static int ext4_wb_handle_extent(struct 
 			pblock, count, inode->i_ino, ec->ec_len);
 
 	/* insert new extent */
-	nex.ee_start = cpu_to_le32(pblock);
-	nex.ee_start_hi = 0;
+	nex.ee_start = cpu_to_le32(pblock & 0xffffffff);
+	nex.ee_start_hi = cpu_to_le16((pblock >> 32) & 0xffff);
 	nex.ee_len = cpu_to_le16(count);
 	nex.ee_block = cpu_to_le32(ec->ec_block);
 	err = ext4_ext_insert_extent(handle, inode, path, &nex);
@@ -529,7 +535,9 @@ static int ext4_wb_handle_extent(struct 
 	 * in correspondend buffer_heads to prevent corruptions */
 	for (i = 0; i < le16_to_cpu(nex.ee_len); i++)
 		unmap_underlying_metadata(sb->s_bdev,
-					  le32_to_cpu(nex.ee_start) + i);
+					  ((ext4_fsblk_t)
+					   le16_to_cpu(nex.ee_start_hi) << 32) +
+					   le32_to_cpu(nex.ee_start) + i);
 
 	/* correct on-disk inode size */
 	if (le16_to_cpu(nex.ee_len) > 0) {
