ext4: Fix lock inversion in ext4_ext_truncate()

From: Jan Kara <jack@suse.cz>

We cannot call ext4_orphan_add() from under i_data_sem because that
causes a lock ordering violation between i_data_sem and and the
superblock lock.

Signed-off-by: Jan Kara <jack@suse.cz>
Signed-off-by: Mingming Cao <cmm@us.ibm.com> 
Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>

---
 fs/ext4/extents.c |    5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

Index: linux-2.6.26-rc6/fs/ext4/extents.c
===================================================================
--- linux-2.6.26-rc6.orig/fs/ext4/extents.c	2008-06-18 15:11:07.000000000 -0700
+++ linux-2.6.26-rc6/fs/ext4/extents.c	2008-06-18 15:11:12.000000000 -0700
@@ -2769,6 +2769,9 @@ void ext4_ext_truncate(struct inode *ino
 	if (inode->i_size & (sb->s_blocksize - 1))
 		ext4_block_truncate_page(handle, mapping, inode->i_size);
 
+	if (ext4_orphan_add(handle, inode))
+		goto out_stop;
+
 	down_write(&EXT4_I(inode)->i_data_sem);
 	ext4_ext_invalidate_cache(inode);
 
@@ -2779,8 +2782,6 @@ void ext4_ext_truncate(struct inode *ino
 	 * Probably we need not scan at all,
 	 * because page truncation is enough.
 	 */
-	if (ext4_orphan_add(handle, inode))
-		goto out_stop;
 
 	/* we have to know where to truncate from in crash case */
 	EXT4_I(inode)->i_disksize = inode->i_size;
