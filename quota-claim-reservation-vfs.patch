quota: Add quota reservation claim and released operations

Reserved quota will be claimed at the block allocation time. Over-booked
quota could be returned back with the release callback function.

Signed-off-by: Mingming Cao <cmm@us.ibm.com>
---
 fs/dquot.c               |   83 +++++++++++++++++++++++++++++++++++++++++++++++
 include/linux/quota.h    |    2 +
 include/linux/quotaops.h |   53 ++++++++++++++++++++++++++++++
 3 files changed, 138 insertions(+)

Index: linux-2.6.28-rc2/include/linux/quota.h
===================================================================
--- linux-2.6.28-rc2.orig/include/linux/quota.h	2008-11-03 13:54:23.000000000 -0800
+++ linux-2.6.28-rc2/include/linux/quota.h	2008-11-03 13:55:09.000000000 -0800
@@ -298,6 +298,8 @@ struct dquot_operations {
 	int (*mark_dirty) (struct dquot *);		/* Dquot is marked dirty */
 	int (*write_info) (struct super_block *, int);	/* Write of quota "superblock" */
 	int (*reserve_space) (struct inode *, qsize_t, int); /* reserve quota for delayed block allocation */
+	int (*claim_space) (struct inode *, qsize_t); /* claim reserved quota for delayed block allocation */
+	void (*release_rsv) (struct inode *, qsize_t); /* release reserved quota for delayed block allocation */
 };
 
 /* Operations handling requests from userspace */
Index: linux-2.6.28-rc2/include/linux/quotaops.h
===================================================================
--- linux-2.6.28-rc2.orig/include/linux/quotaops.h	2008-11-03 13:54:23.000000000 -0800
+++ linux-2.6.28-rc2/include/linux/quotaops.h	2008-11-03 13:55:09.000000000 -0800
@@ -28,6 +28,11 @@ int dquot_drop(struct inode *inode);
 int dquot_alloc_space(struct inode *inode, qsize_t number, int prealloc);
 int dquot_alloc_inode(const struct inode *inode, unsigned long number);
 
+int dquot_reserve_space(struct inode *inode, qsize_t number, int prealloc);
+int dquot_claim_space(struct inode *inode, qsize_t number);
+void dquot_release_reserved_space(struct inode *inode, qsize_t number);
+
+
 int dquot_free_space(struct inode *inode, qsize_t number);
 int dquot_free_inode(const struct inode *inode, unsigned long number);
 
@@ -170,6 +175,31 @@ static inline int vfs_dq_alloc_inode(str
 	return 0;
 }
 
+/*
+ * Convert in-memory reserved quotas to real consumed quotas
+ */
+static inline int vfs_dq_claim_space(struct inode *inode, qsize_t nr)
+{
+	if (sb_any_quota_enabled(inode->i_sb)){
+		if (inode->i_sb->dq_op->claim_space(inode, nr) == NO_QUOTA)
+			return 1;
+	}
+	else
+		inode_add_bytes(inode, nr);
+
+	mark_inode_dirty(inode);
+	return 0;
+}
+
+/*
+ * Release reserved (in-memory) quotas
+ */
+static inline void vfs_dq_release_reservation_space(struct inode *inode, qsize_t nr)
+{
+	if (sb_any_quota_enabled(inode->i_sb))
+		inode->i_sb->dq_op->release_rsv(inode, nr);
+}
+
 static inline void vfs_dq_free_space_nodirty(struct inode *inode, qsize_t nr)
 {
 	if (sb_any_quota_enabled(inode->i_sb))
@@ -300,6 +330,16 @@ static inline int vfs_dq_reserve_space(s
 	return 0;
 }
 
+static inline int vfs_dq_claim_space(struct inode *inode, qsize_t nr)
+{
+	return vfs_dq_alloc_space(inode, nr);
+}
+
+static inline int vfs_dq_release_reservation_space(struct inode *inode, qsize_t nr)
+{
+	return 0;
+}
+
 static inline void vfs_dq_free_space_nodirty(struct inode *inode, qsize_t nr)
 {
 	inode_sub_bytes(inode, nr);
@@ -344,6 +384,17 @@ static inline int vfs_dq_reserve_block(s
 			nr << inode->i_sb->s_blocksize_bits);
 }
 
+static inline int vfs_dq_claim_block(struct inode *inode, qsize_t nr)
+{
+	return vfs_dq_claim_space(inode,
+			nr << inode->i_sb->s_blocksize_bits);
+}
+
+static inline void vfs_dq_release_reservation(struct inode *inode, qsize_t nr)
+{
+	vfs_dq_release_reservation_space(inode, nr << inode->i_sb->s_blocksize_bits);
+}
+
 static inline void vfs_dq_free_block_nodirty(struct inode *inode, qsize_t nr)
 {
 	vfs_dq_free_space_nodirty(inode, nr << inode->i_sb->s_blocksize_bits);
@@ -373,6 +424,8 @@ static inline void vfs_dq_free_block(str
 				vfs_dq_alloc_block_nodirty(inode, nr)
 #define DQUOT_ALLOC_BLOCK(inode, nr) vfs_dq_alloc_block(inode, nr)
 #define DQUOT_RESERVE_BLOCK(inode, nr) vfs_dq_reserve_block(inode, nr)
+#define DQUOT_CLAIM_BLOCK(inode, nr) vfs_dq_claim_block(inode, nr)
+#define DQUOT_RELEASE_RSV_BLOCK(inode, nr) vfs_dq_release_reservation(inode, nr)
 #define DQUOT_ALLOC_INODE(inode) vfs_dq_alloc_inode(inode)
 #define DQUOT_FREE_SPACE_NODIRTY(inode, nr) \
 				vfs_dq_free_space_nodirty(inode, nr)
Index: linux-2.6.28-rc2/fs/dquot.c
===================================================================
--- linux-2.6.28-rc2.orig/fs/dquot.c	2008-11-03 13:54:23.000000000 -0800
+++ linux-2.6.28-rc2/fs/dquot.c	2008-11-03 13:55:09.000000000 -0800
@@ -834,6 +834,22 @@ static inline void dquot_resv_space(stru
 {
 	dquot->dq_dqb.dqb_rsvspace += number;
 }
+/*
+ * Claim reserved quota space
+ */
+static int dquot_claim_reserved_space(struct dquot *dquot, qsize_t number)
+{
+	if (dquot->dq_dqb.dqb_rsvspace < number) {
+		printk("WARNING: reserved quota %llu is not enough for"
+			"request %llu bytes\n",
+			dquot->dq_dqb.dqb_rsvspace, number);
+		return 1;
+	}
+
+	dquot->dq_dqb.dqb_curspace += number;
+	dquot->dq_dqb.dqb_rsvspace -= number;
+	return 0;
+}
 
 static inline void dquot_decr_inodes(struct dquot *dquot, unsigned long number)
 {
@@ -1313,6 +1329,71 @@ int dquot_reserve_space(struct inode *in
 	return ret;
 }
 
+int dquot_claim_space(struct inode *inode, qsize_t number)
+{
+	int cnt;
+	int ret = QUOTA_OK;
+
+	if (IS_NOQUOTA(inode)) {
+		inode_add_bytes(inode, number);
+		return ret;
+	}
+
+	down_read(&sb_dqopt(inode->i_sb)->dqptr_sem);
+	if (IS_NOQUOTA(inode))	{
+		up_read(&sb_dqopt(inode->i_sb)->dqptr_sem);
+		inode_add_bytes(inode, number);
+		return ret;
+	}
+
+	/* Claim reserved quotas to allocated quotas */
+	for (cnt = 0; cnt < MAXQUOTAS; cnt++) {
+		if (inode->i_dquot[cnt] != NODQUOT)
+			ret = dquot_claim_reserved_space(inode->i_dquot[cnt],
+							number);
+	}
+	if (ret == NO_QUOTA) {
+		up_read(&sb_dqopt(inode->i_sb)->dqptr_sem);
+		return ret;
+	}
+	/* Dirtify all the dquots - this can block when journalling */
+	for (cnt = 0; cnt < MAXQUOTAS; cnt++)
+		if (inode->i_dquot[cnt])
+			mark_dquot_dirty(inode->i_dquot[cnt]);
+	up_read(&sb_dqopt(inode->i_sb)->dqptr_sem);
+
+	/* Update inode bytes */
+	inode_add_bytes(inode, number);
+	return ret;
+}
+
+/*
+ * Release reserved quota space
+ */
+void dquot_release_reserved_space(struct inode *inode, qsize_t number)
+{
+	int cnt;
+	struct dquot *dquot;
+
+	if (IS_NOQUOTA(inode))
+		return;
+
+	down_read(&sb_dqopt(inode->i_sb)->dqptr_sem);
+	if (IS_NOQUOTA(inode))	{
+		up_read(&sb_dqopt(inode->i_sb)->dqptr_sem);
+		return;
+	}
+
+	/* Release reserved dquots */
+	for (cnt = 0; cnt < MAXQUOTAS; cnt++) {
+		if (inode->i_dquot[cnt] != NODQUOT) {
+			dquot = inode->i_dquot[cnt];
+			dquot->dq_dqb.dqb_rsvspace -= number;
+		}
+	}
+	up_read(&sb_dqopt(inode->i_sb)->dqptr_sem);
+}
+
 /*
  * This operation can block, but only after everything is updated
  */
@@ -2260,6 +2341,8 @@ EXPORT_SYMBOL(dquot_alloc_inode);
 EXPORT_SYMBOL(dquot_free_space);
 EXPORT_SYMBOL(dquot_free_inode);
 EXPORT_SYMBOL(dquot_reserve_space);
+EXPORT_SYMBOL(dquot_claim_space);
+EXPORT_SYMBOL(dquot_release_reserved_space);
 EXPORT_SYMBOL(dquot_transfer);
 EXPORT_SYMBOL(vfs_dq_transfer);
 EXPORT_SYMBOL(vfs_dq_quota_on_remount);
